{"ast":null,"code":"import _createForOfIteratorHelper from \"/mnt/c/Users/dcmcc/Desktop/dan-mccarthy265.github.io/simple_web3_app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { encodeUint, bufPaddedLength, buffLength } from '../common';\nimport { ethersAbi, falseEncoded, trueEncoded } from './constants';\nvar selector = ethersAbi.getSighash('tryAggregate');\nexport function encodeCalls(start, calls) {\n  var res = start; // the first offset is calls.length * 0x20 because the first\n  // item of a dynamic array starts after all offsets\n\n  var dynamicOffset = calls.length * 0x20; // number of items in the array\n\n  res += encodeUint(calls.length);\n\n  var _iterator = _createForOfIteratorHelper(calls),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var call = _step.value;\n      // offset of the current call\n      res += encodeUint(dynamicOffset); // offset for the next call - current offset\n      // + length of the current call\n      // + space taken by the current offset\n      // + the first item in the next tuple - address for the next call\n      // + space taken by the offset for the next call data\n\n      dynamicOffset += 3 * 0x20 + bufPaddedLength(call[1]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  var _iterator2 = _createForOfIteratorHelper(calls),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _call = _step2.value;\n      // address + calldata offset\n      dynamicOffset = 0x40;\n      res += '000000000000000000000000' + _call[0].slice(2).toLowerCase();\n      res += encodeUint(dynamicOffset); // call data length\n\n      res += buffLength(_call[1]).toString(16).padStart(64, '0'); // calldata\n\n      res += _call[1].slice(2).padEnd(bufPaddedLength(_call[1]) * 2, '0');\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return res;\n}\nexport function encodeTryAggregate(b, calls) {\n  // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n  var res = selector; // offset of the array is 0x40 because we need to\n  // encode requireSuccess flag and the offset itself\n\n  var dynamicOffset = 0x40;\n  res += b ? trueEncoded : falseEncoded;\n  res += encodeUint(dynamicOffset); // encode dynamic array of calls\n\n  return encodeCalls(res, calls);\n}","map":{"version":3,"mappings":";AAAA,SAASA,UAAT,EAAqBC,eAArB,EAAsCC,UAAtC,QAAwD,WAAxD;AACA,SAASC,SAAT,EAAoBC,YAApB,EAAkCC,WAAlC,QAAqD,aAArD;AAEA,IAAMC,QAAQ,GAAGH,SAAS,CAACI,UAAV,CAAqB,cAArB,CAAjB;AAEA,OAAM,SAAUC,WAAV,CAAsBC,KAAtB,EAAqCC,KAArC,EAA8D;EAClE,IAAIC,GAAG,GAAGF,KAAV,CADkE,CAElE;EACA;;EACA,IAAIG,aAAa,GAAGF,KAAK,CAACG,MAAN,GAAe,IAAnC,CAJkE,CAKlE;;EACAF,GAAG,IAAIX,UAAU,CAACU,KAAK,CAACG,MAAP,CAAjB;;EANkE,2CAO/CH,KAP+C;EAAA;;EAAA;IAOlE,oDAA0B;MAAA,IAAfI,IAAe;MACxB;MACAH,GAAG,IAAIX,UAAU,CAACY,aAAD,CAAjB,CAFwB,CAGxB;MACA;MACA;MACA;MACA;;MACAA,aAAa,IAAI,IAAI,IAAJ,GAAWX,eAAe,CAACa,IAAI,CAAC,CAAD,CAAL,CAA3C;IACD;EAhBiE;IAAA;EAAA;IAAA;EAAA;;EAAA,4CAkB/CJ,KAlB+C;EAAA;;EAAA;IAkBlE,uDAA0B;MAAA,IAAfI,KAAe;MACxB;MACAF,aAAa,GAAG,IAAhB;MACAD,GAAG,IAAI,6BAA6BG,KAAI,CAAC,CAAD,CAAJ,CAAQC,KAAR,CAAc,CAAd,EAAiBC,WAAjB,EAApC;MACAL,GAAG,IAAIX,UAAU,CAACY,aAAD,CAAjB,CAJwB,CAMxB;;MACAD,GAAG,IAAIT,UAAU,CAACY,KAAI,CAAC,CAAD,CAAL,CAAV,CAAoBG,QAApB,CAA6B,EAA7B,EAAiCC,QAAjC,CAA0C,EAA1C,EAA8C,GAA9C,CAAP,CAPwB,CAQxB;;MACAP,GAAG,IAAIG,KAAI,CAAC,CAAD,CAAJ,CAAQC,KAAR,CAAc,CAAd,EAAiBI,MAAjB,CAAwBlB,eAAe,CAACa,KAAI,CAAC,CAAD,CAAL,CAAf,GAA2B,CAAnD,EAAsD,GAAtD,CAAP;IACD;EA5BiE;IAAA;EAAA;IAAA;EAAA;;EA8BlE,OAAOH,GAAP;AACD;AAED,OAAM,SAAUS,kBAAV,CAA6BC,CAA7B,EAAyCX,KAAzC,EAAkE;EACtE;EACA,IAAIC,GAAG,GAAGL,QAAV,CAFsE,CAItE;EACA;;EACA,IAAMM,aAAa,GAAG,IAAtB;EACAD,GAAG,IAAIU,CAAC,GAAGhB,WAAH,GAAiBD,YAAzB;EACAO,GAAG,IAAIX,UAAU,CAACY,aAAD,CAAjB,CARsE,CAUtE;;EACA,OAAOJ,WAAW,CAACG,GAAD,EAAMD,KAAN,CAAlB;AACD","names":["encodeUint","bufPaddedLength","buffLength","ethersAbi","falseEncoded","trueEncoded","selector","getSighash","encodeCalls","start","calls","res","dynamicOffset","length","call","slice","toLowerCase","toString","padStart","padEnd","encodeTryAggregate","b"],"sources":["/mnt/c/Users/dcmcc/Desktop/dan-mccarthy265.github.io/simple_web3_app/node_modules/@usedapp/core/src/abi/multicall2/encoder.ts"],"sourcesContent":["import { encodeUint, bufPaddedLength, buffLength } from '../common'\nimport { ethersAbi, falseEncoded, trueEncoded } from './constants'\n\nconst selector = ethersAbi.getSighash('tryAggregate')\n\nexport function encodeCalls(start: string, calls: [string, string][]) {\n  let res = start\n  // the first offset is calls.length * 0x20 because the first\n  // item of a dynamic array starts after all offsets\n  let dynamicOffset = calls.length * 0x20\n  // number of items in the array\n  res += encodeUint(calls.length)\n  for (const call of calls) {\n    // offset of the current call\n    res += encodeUint(dynamicOffset)\n    // offset for the next call - current offset\n    // + length of the current call\n    // + space taken by the current offset\n    // + the first item in the next tuple - address for the next call\n    // + space taken by the offset for the next call data\n    dynamicOffset += 3 * 0x20 + bufPaddedLength(call[1])\n  }\n\n  for (const call of calls) {\n    // address + calldata offset\n    dynamicOffset = 0x40\n    res += '000000000000000000000000' + call[0].slice(2).toLowerCase()\n    res += encodeUint(dynamicOffset)\n\n    // call data length\n    res += buffLength(call[1]).toString(16).padStart(64, '0')\n    // calldata\n    res += call[1].slice(2).padEnd(bufPaddedLength(call[1]) * 2, '0')\n  }\n\n  return res\n}\n\nexport function encodeTryAggregate(b: boolean, calls: [string, string][]) {\n  // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n  let res = selector\n\n  // offset of the array is 0x40 because we need to\n  // encode requireSuccess flag and the offset itself\n  const dynamicOffset = 0x40\n  res += b ? trueEncoded : falseEncoded\n  res += encodeUint(dynamicOffset)\n\n  // encode dynamic array of calls\n  return encodeCalls(res, calls)\n}\n"]},"metadata":{},"sourceType":"module"}