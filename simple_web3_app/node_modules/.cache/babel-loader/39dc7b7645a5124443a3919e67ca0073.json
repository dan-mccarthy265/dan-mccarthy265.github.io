{"ast":null,"code":"// number of bytes in the hext string - '0x' at the start doesn't count\n// each two characters are one byte\nexport var buffLength = function buffLength(buf) {\n  return (buf.length - 2) / 2;\n}; // length of the buffer padded to the nearest 32 bytes\n\nexport var bufPaddedLength = function bufPaddedLength(buf) {\n  return Math.ceil(buffLength(buf) / 32) * 32;\n};\nexport var encodeUint = function encodeUint(uint) {\n  return uint.toString(16).padStart(64, '0');\n};\nexport var decodeUint = function decodeUint(buf) {\n  return parseInt(buf, 16);\n}; // word length in characters - 32 bytes = 64 characters\n\nexport var wordLength = 64;\nexport var fail = function fail() {\n  throw new Error('Invalid calldata');\n};","map":{"version":3,"mappings":"AAAA;AACA;AACA,OAAO,IAAMA,UAAU,GAAG,SAAbA,UAAa,CAACC,GAAD;EAAA,OAAiB,CAACA,GAAG,CAACC,MAAJ,GAAa,CAAd,IAAmB,CAApC;AAAA,CAAnB,C,CACP;;AACA,OAAO,IAAMC,eAAe,GAAG,SAAlBA,eAAkB,CAACF,GAAD;EAAA,OAAiBG,IAAI,CAACC,IAAL,CAAUL,UAAU,CAACC,GAAD,CAAV,GAAkB,EAA5B,IAAkC,EAAnD;AAAA,CAAxB;AACP,OAAO,IAAMK,UAAU,GAAG,SAAbA,UAAa,CAACC,IAAD;EAAA,OAAkBA,IAAI,CAACC,QAAL,CAAc,EAAd,EAAkBC,QAAlB,CAA2B,EAA3B,EAA+B,GAA/B,CAAlB;AAAA,CAAnB;AACP,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAACT,GAAD;EAAA,OAAiBU,QAAQ,CAACV,GAAD,EAAM,EAAN,CAAzB;AAAA,CAAnB,C,CACP;;AACA,OAAO,IAAMW,UAAU,GAAG,EAAnB;AACP,OAAO,IAAMC,IAAI,GAAG,SAAPA,IAAO,GAAK;EACvB,MAAM,IAAIC,KAAJ,CAAU,kBAAV,CAAN;AACD,CAFM","names":["buffLength","buf","length","bufPaddedLength","Math","ceil","encodeUint","uint","toString","padStart","decodeUint","parseInt","wordLength","fail","Error"],"sources":["C:\\Users\\dcmcc\\Desktop\\dan-mccarthy265.github.io\\simple_web3_app\\node_modules\\@usedapp\\core\\src\\abi\\common.ts"],"sourcesContent":["// number of bytes in the hext string - '0x' at the start doesn't count\n// each two characters are one byte\nexport const buffLength = (buf: string) => (buf.length - 2) / 2\n// length of the buffer padded to the nearest 32 bytes\nexport const bufPaddedLength = (buf: string) => Math.ceil(buffLength(buf) / 32) * 32\nexport const encodeUint = (uint: number) => uint.toString(16).padStart(64, '0')\nexport const decodeUint = (buf: string) => parseInt(buf, 16)\n// word length in characters - 32 bytes = 64 characters\nexport const wordLength = 64\nexport const fail = () => {\n  throw new Error('Invalid calldata')\n}\n"]},"metadata":{},"sourceType":"module"}