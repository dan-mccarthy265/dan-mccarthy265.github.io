{"ast":null,"code":"import { useMemo } from 'react';\nimport { useRawCalls } from './useRawCalls';\nimport { decodeCallResult, encodeCallData } from '../helpers';\nimport { useChainId } from './useChainId';\n/**\n * Makes a call to a specific method of a specific contract and returns the value or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useRawCall} that uses ABI, function name, and arguments instead of raw data.\n * If typechain contract is used in `call` parameter then method name and arguments will be type checked.\n * Result will be typed as well.\n *\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n *\n * @public\n * @param call a single call to a contract, also see {@link Call}\n * @returns The hook returns {@link CallResult} type.\n *\n * @example\n * function useTotalSupply(tokenAddress: string | undefined): BigNumber | undefined {\n *    const { value, error } = useCall(tokenAddress && {\n *      contract: new Contract(tokenAddress, ERC20Interface),\n *      method: 'totalSupply',\n *      args: []\n *    }) ?? {}\n *    if(error) {\n *      console.error(error.message)\n *      return undefined\n *    }\n *    return value?.[0]\n * }\n */\n\nexport function useCall(call) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return useCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific methods of specific contracts and returns values or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useRawCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls, also see {@link Call}.\n * @param queryParams see {@link QueryParams}.\n * @returns a list of results (see {@link CallResult}).\n *\n * @example\n * function useTotalSupplies(tokenAddresses: string[] | undefined): (BigNumber | undefined)[] {\n *   const calls = tokenAddresses?.map(address => ({\n *     contract: new Contract(address, ERC20Interface),\n *     method: 'totalSupply',\n *     args: []\n *   })) ?? []\n *   const results = useCalls(calls) ?? []\n *   results.forEach((result, idx) => {\n *     if(result && result.error) {\n *       console.error(`Error encountered calling 'totalSupply' on ${calls[idx]?.contract.address}: ${result.error.message}`)\n *     }\n *   })\n *   return results.map(result => result?.value?.[0])\n * }\n */\n\nexport function useCalls(calls) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var chainId = useChainId({\n    queryParams: queryParams\n  });\n  var isStatic = queryParams.isStatic;\n  var rawCalls = useMemo(function () {\n    return calls.map(function (call) {\n      return chainId !== undefined ? encodeCallData(call, chainId, isStatic) : undefined;\n    });\n  }, [JSON.stringify(calls.map(function (call) {\n    return call && {\n      address: call.contract.address.toLowerCase(),\n      method: call.method,\n      args: call.args\n    };\n  })), chainId]);\n  var results = useRawCalls(rawCalls);\n  return useMemo(function () {\n    return results.map(function (result, idx) {\n      return decodeCallResult(calls[idx], result);\n    });\n  }, [results]);\n}","map":{"version":3,"mappings":"AAAA,SAASA,OAAT,QAAwB,OAAxB;AAGA,SAASC,WAAT,QAA4B,eAA5B;AACA,SAAqBC,gBAArB,EAAuCC,cAAvC,QAA6D,YAA7D;AAEA,SAASC,UAAT,QAA2B,cAA3B;AAWA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,OAAM,SAAUC,OAAV,CACJC,IADI,EAEyB;EAAA,IAA7BC,WAA6B,uEAAF,EAAE;EAE7B,OAAOC,QAAQ,CAAC,CAACF,IAAD,CAAD,EAASC,WAAT,CAAR,CAA8B,CAA9B,CAAP;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAM,SAAUC,QAAV,CAAmBC,KAAnB,EAAyE;EAAA,IAA7BF,WAA6B,uEAAF,EAAE;EAC7E,IAAMG,OAAO,GAAGN,UAAU,CAAC;IAAEG,WAAW,EAAXA;EAAF,CAAD,CAA1B;EACA,IAAQI,QAAR,GAAqBJ,WAArB,CAAQI,QAAR;EAEA,IAAMC,QAAQ,GAAGZ,OAAO,CACtB;IAAA,OAAMS,KAAK,CAACI,GAAN,CAAU,UAACP,IAAD;MAAA,OAAWI,OAAO,KAAKI,SAAZ,GAAwBX,cAAc,CAACG,IAAD,EAAOI,OAAP,EAAgBC,QAAhB,CAAtC,GAAkEG,SAA7E;IAAA,CAAV,CAAN;EAAA,CADsB,EAEtB,CACEC,IAAI,CAACC,SAAL,CACEP,KAAK,CAACI,GAAN,CACE,UAACP,IAAD;IAAA,OAAUA,IAAI,IAAI;MAAEW,OAAO,EAAEX,IAAI,CAACY,QAAL,CAAcD,OAAd,CAAsBE,WAAtB,EAAX;MAAgDC,MAAM,EAAEd,IAAI,CAACc,MAA7D;MAAqEC,IAAI,EAAEf,IAAI,CAACe;IAAhF,CAAlB;EAAA,CADF,CADF,CADF,EAMEX,OANF,CAFsB,CAAxB;EAWA,IAAMY,OAAO,GAAGrB,WAAW,CAACW,QAAD,CAA3B;EACA,OAAOZ,OAAO,CAAC;IAAA,OAAMsB,OAAO,CAACT,GAAR,CAAY,UAACU,MAAD,EAASC,GAAT;MAAA,OAAiBtB,gBAAgB,CAACO,KAAK,CAACe,GAAD,CAAN,EAAaD,MAAb,CAAjC;IAAA,CAAZ,CAAN;EAAA,CAAD,EAA2E,CAACD,OAAD,CAA3E,CAAd;AACD","names":["useMemo","useRawCalls","decodeCallResult","encodeCallData","useChainId","useCall","call","queryParams","useCalls","calls","chainId","isStatic","rawCalls","map","undefined","JSON","stringify","address","contract","toLowerCase","method","args","results","result","idx"],"sources":["C:\\Users\\dcmcc\\Desktop\\dan-mccarthy265.github.io\\simple_web3_app\\node_modules\\@usedapp\\core\\src\\hooks\\useCall.ts"],"sourcesContent":["import { useMemo } from 'react'\nimport { Contract } from 'ethers'\nimport { ContractMethodNames, Falsy, Params, TypedContract } from '../model/types'\nimport { useRawCalls } from './useRawCalls'\nimport { CallResult, decodeCallResult, encodeCallData } from '../helpers'\nimport { QueryParams } from '../constants/type/QueryParams'\nimport { useChainId } from './useChainId'\n\n/**\n * @public\n */\nexport interface Call<T extends TypedContract = Contract, MN extends ContractMethodNames<T> = ContractMethodNames<T>> {\n  contract: T\n  method: MN\n  args: Params<T, MN>\n}\n\n/**\n * Makes a call to a specific method of a specific contract and returns the value or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useRawCall} that uses ABI, function name, and arguments instead of raw data.\n * If typechain contract is used in `call` parameter then method name and arguments will be type checked.\n * Result will be typed as well.\n *\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n *\n * @public\n * @param call a single call to a contract, also see {@link Call}\n * @returns The hook returns {@link CallResult} type.\n *\n * @example\n * function useTotalSupply(tokenAddress: string | undefined): BigNumber | undefined {\n *    const { value, error } = useCall(tokenAddress && {\n *      contract: new Contract(tokenAddress, ERC20Interface),\n *      method: 'totalSupply',\n *      args: []\n *    }) ?? {}\n *    if(error) {\n *      console.error(error.message)\n *      return undefined\n *    }\n *    return value?.[0]\n * }\n */\nexport function useCall<T extends TypedContract, MN extends ContractMethodNames<T>>(\n  call: Call<T, MN> | Falsy,\n  queryParams: QueryParams = {}\n): CallResult<T, MN> {\n  return useCalls([call], queryParams)[0]\n}\n\n/**\n * Makes calls to specific methods of specific contracts and returns values or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useRawCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls, also see {@link Call}.\n * @param queryParams see {@link QueryParams}.\n * @returns a list of results (see {@link CallResult}).\n *\n * @example\n * function useTotalSupplies(tokenAddresses: string[] | undefined): (BigNumber | undefined)[] {\n *   const calls = tokenAddresses?.map(address => ({\n *     contract: new Contract(address, ERC20Interface),\n *     method: 'totalSupply',\n *     args: []\n *   })) ?? []\n *   const results = useCalls(calls) ?? []\n *   results.forEach((result, idx) => {\n *     if(result && result.error) {\n *       console.error(`Error encountered calling 'totalSupply' on ${calls[idx]?.contract.address}: ${result.error.message}`)\n *     }\n *   })\n *   return results.map(result => result?.value?.[0])\n * }\n */\nexport function useCalls(calls: (Call | Falsy)[], queryParams: QueryParams = {}): CallResult<Contract, string>[] {\n  const chainId = useChainId({ queryParams })\n  const { isStatic } = queryParams\n\n  const rawCalls = useMemo(\n    () => calls.map((call) => (chainId !== undefined ? encodeCallData(call, chainId, isStatic) : undefined)),\n    [\n      JSON.stringify(\n        calls.map(\n          (call) => call && { address: call.contract.address.toLowerCase(), method: call.method, args: call.args }\n        )\n      ),\n      chainId,\n    ]\n  )\n  const results = useRawCalls(rawCalls)\n  return useMemo(() => results.map((result, idx) => decodeCallResult(calls[idx], result)), [results])\n}\n"]},"metadata":{},"sourceType":"module"}