{"ast":null,"code":"import _slicedToArray from \"C:/Users/dcmcc/Desktop/dan-mccarthy265.github.io/simple_web3_app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useReducer } from 'react';\nimport { useDebouncePair, useBlockNumbers } from '../../../hooks';\nimport { MultiChainStatesContext } from './context';\nimport { useConfig, useNetwork } from '../../..';\nimport { useReadonlyNetworks } from '../../network';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { performMulticall } from '../common/performMulticall';\nimport { callsReducer, chainStateReducer, multicall1Factory, multicall2Factory } from '../common';\nimport { getUniqueActiveCalls } from '../../../helpers';\nimport { useDevtoolsReporting } from '../common/useDevtoolsReporting';\nimport { useChainId } from '../../../hooks/useChainId';\n\nfunction composeChainState(networks, state, multicallAddresses) {\n  return fromEntries(Object.keys(networks).map(function (chainId) {\n    return [Number(chainId), {\n      value: state[Number(chainId)],\n      multicallAddress: multicallAddresses[Number(chainId)]\n    }];\n  }));\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\n\nexport function MultiChainStateProvider(_ref) {\n  var children = _ref.children,\n      multicallAddresses = _ref.multicallAddresses;\n\n  var _useConfig = useConfig(),\n      multicallVersion = _useConfig.multicallVersion,\n      fastMulticallEncoding = _useConfig.fastMulticallEncoding;\n\n  var networks = useReadonlyNetworks();\n  var blockNumbers = useBlockNumbers();\n\n  var _useNetwork = useNetwork(),\n      reportError = _useNetwork.reportError;\n\n  var _useReducer = useReducer(callsReducer, []),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      calls = _useReducer2[0],\n      dispatchCalls = _useReducer2[1];\n\n  var _useReducer3 = useReducer(chainStateReducer, {}),\n      _useReducer4 = _slicedToArray(_useReducer3, 2),\n      state = _useReducer4[0],\n      dispatchState = _useReducer4[1];\n\n  var multicall = (multicallVersion === 1 ? multicall1Factory : multicall2Factory)(fastMulticallEncoding !== null && fastMulticallEncoding !== void 0 ? fastMulticallEncoding : false);\n\n  var _useDebouncePair = useDebouncePair(calls, networks, 50),\n      _useDebouncePair2 = _slicedToArray(_useDebouncePair, 2),\n      debouncedCalls = _useDebouncePair2[0],\n      debouncedNetworks = _useDebouncePair2[1];\n\n  var uniqueCalls = useMemo(function () {\n    return getUniqueActiveCalls(debouncedCalls);\n  }, [debouncedCalls]); // used for deep equality in hook dependencies\n\n  var uniqueCallsJSON = JSON.stringify(debouncedCalls);\n  var chainId = useChainId();\n  useDevtoolsReporting(uniqueCallsJSON, uniqueCalls, chainId !== undefined ? blockNumbers[chainId] : undefined, multicallAddresses);\n\n  function multicallForChain(chainId, provider) {\n    var blockNumber = blockNumbers[chainId];\n    var multicallAddress = multicallAddresses[chainId];\n\n    if (!provider || !blockNumber) {\n      return;\n    }\n\n    if (!multicallAddress) {\n      reportError(new Error(\"Missing multicall address for chain id \".concat(chainId)));\n      return;\n    }\n\n    if (debouncedNetworks !== networks) {\n      // Wait for debounce to catch up.\n      return;\n    }\n\n    var callsOnThisChain = uniqueCalls.filter(function (call) {\n      return call.chainId === chainId;\n    });\n\n    if (callsOnThisChain.length === 0) {\n      return;\n    }\n\n    performMulticall(provider, multicall, multicallAddress, blockNumber, callsOnThisChain, dispatchState, chainId, reportError);\n    dispatchCalls({\n      type: 'UPDATE_CALLS',\n      calls: calls\n    });\n  }\n\n  useEffect(function () {\n    for (var _i = 0, _Object$entries = Object.entries(networks); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n          _chainId = _Object$entries$_i[0],\n          provider = _Object$entries$_i[1];\n\n      multicallForChain(Number(_chainId), provider);\n    }\n  }, [blockNumbers, networks, multicallAddresses, uniqueCallsJSON]);\n  var chains = useMemo(function () {\n    return composeChainState(networks, state, multicallAddresses);\n  }, [state, multicallAddresses, networks]);\n  var provided = {\n    chains: chains,\n    dispatchCalls: dispatchCalls\n  };\n  return _jsx(MultiChainStatesContext.Provider, {\n    value: provided,\n    children: children\n  });\n}","map":{"version":3,"mappings":"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","names":["useEffect","useMemo","useReducer","useDebouncePair","useBlockNumbers","MultiChainStatesContext","useConfig","useNetwork","useReadonlyNetworks","fromEntries","performMulticall","callsReducer","chainStateReducer","multicall1Factory","multicall2Factory","getUniqueActiveCalls","useDevtoolsReporting","useChainId","composeChainState","networks","state","multicallAddresses","Object","keys","map","chainId","Number","value","multicallAddress","MultiChainStateProvider","children","multicallVersion","fastMulticallEncoding","blockNumbers","reportError","calls","dispatchCalls","dispatchState","multicall","debouncedCalls","debouncedNetworks","uniqueCalls","uniqueCallsJSON","JSON","stringify","undefined","multicallForChain","provider","blockNumber","Error","callsOnThisChain","filter","call","length","type","entries","_chainId","chains","provided","_jsx","Provider"],"sources":["C:\\Users\\dcmcc\\Desktop\\dan-mccarthy265.github.io\\simple_web3_app\\node_modules\\@usedapp\\core\\src\\providers\\chainState\\multiChainStates\\provider.tsx"],"sourcesContent":["import { ReactNode, useEffect, useMemo, useReducer } from 'react'\nimport { useDebouncePair, useBlockNumbers } from '../../../hooks'\nimport { MultiChainStatesContext } from './context'\nimport { ChainId, State, useConfig, useNetwork } from '../../..'\nimport { useReadonlyNetworks } from '../../network'\nimport { fromEntries } from '../../../helpers/fromEntries'\nimport { performMulticall } from '../common/performMulticall'\nimport { Providers } from '../../network/readonlyNetworks/model'\nimport { BaseProvider } from '@ethersproject/providers'\nimport { callsReducer, chainStateReducer, multicall1Factory, multicall2Factory } from '../common'\nimport { getUniqueActiveCalls } from '../../../helpers'\nimport { useDevtoolsReporting } from '../common/useDevtoolsReporting'\nimport { useChainId } from '../../../hooks/useChainId'\n\ninterface Props {\n  children: ReactNode\n  multicallAddresses: {\n    [chainId: number]: string\n  }\n}\n\nfunction composeChainState(networks: Providers, state: State, multicallAddresses: Props['multicallAddresses']) {\n  return fromEntries(\n    Object.keys(networks).map((chainId) => [\n      Number(chainId),\n      {\n        value: state[Number(chainId)],\n        multicallAddress: multicallAddresses[Number(chainId)],\n      },\n    ])\n  )\n}\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function MultiChainStateProvider({ children, multicallAddresses }: Props) {\n  const { multicallVersion, fastMulticallEncoding } = useConfig()\n  const networks = useReadonlyNetworks()\n  const blockNumbers = useBlockNumbers()\n  const { reportError } = useNetwork()\n\n  const [calls, dispatchCalls] = useReducer(callsReducer, [])\n  const [state, dispatchState] = useReducer(chainStateReducer, {})\n\n  const multicall = (multicallVersion === 1 ? multicall1Factory : multicall2Factory)(fastMulticallEncoding ?? false)\n\n  const [debouncedCalls, debouncedNetworks] = useDebouncePair(calls, networks, 50)\n  const uniqueCalls = useMemo(() => getUniqueActiveCalls(debouncedCalls), [debouncedCalls])\n\n  // used for deep equality in hook dependencies\n  const uniqueCallsJSON = JSON.stringify(debouncedCalls)\n\n  const chainId = useChainId()\n  useDevtoolsReporting(\n    uniqueCallsJSON,\n    uniqueCalls,\n    chainId !== undefined ? blockNumbers[chainId as ChainId] : undefined,\n    multicallAddresses\n  )\n\n  function multicallForChain(chainId: ChainId, provider?: BaseProvider) {\n    const blockNumber = blockNumbers[chainId]\n    const multicallAddress = multicallAddresses[chainId]\n\n    if (!provider || !blockNumber) {\n      return\n    }\n    if (!multicallAddress) {\n      reportError(new Error(`Missing multicall address for chain id ${chainId}`))\n      return\n    }\n    if (debouncedNetworks !== networks) {\n      // Wait for debounce to catch up.\n      return\n    }\n\n    const callsOnThisChain = uniqueCalls.filter((call) => call.chainId === chainId)\n    if (callsOnThisChain.length === 0) {\n      return\n    }\n    performMulticall(\n      provider,\n      multicall,\n      multicallAddress,\n      blockNumber,\n      callsOnThisChain,\n      dispatchState,\n      chainId,\n      reportError\n    )\n    dispatchCalls({ type: 'UPDATE_CALLS', calls })\n  }\n\n  useEffect(() => {\n    for (const [_chainId, provider] of Object.entries(networks)) {\n      multicallForChain(Number(_chainId), provider)\n    }\n  }, [blockNumbers, networks, multicallAddresses, uniqueCallsJSON])\n\n  const chains = useMemo(() => composeChainState(networks, state, multicallAddresses), [\n    state,\n    multicallAddresses,\n    networks,\n  ])\n\n  const provided = { chains, dispatchCalls }\n\n  return <MultiChainStatesContext.Provider value={provided} children={children} />\n}\n"]},"metadata":{},"sourceType":"module"}