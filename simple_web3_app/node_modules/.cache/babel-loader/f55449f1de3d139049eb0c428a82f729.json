{"ast":null,"code":"import _regeneratorRuntime from \"/mnt/c/Users/dcmcc/Desktop/dan-mccarthy265.github.io/simple_web3_app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toConsumableArray from \"/mnt/c/Users/dcmcc/Desktop/dan-mccarthy265.github.io/simple_web3_app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"/mnt/c/Users/dcmcc/Desktop/dan-mccarthy265.github.io/simple_web3_app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/mnt/c/Users/dcmcc/Desktop/dan-mccarthy265.github.io/simple_web3_app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useConfig } from '../../src';\nimport { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { estimateGasLimit, usePromiseTransaction } from './usePromiseTransaction';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function connectContractToSigner(contract, options, library) {\n  if (contract.signer) {\n    return contract;\n  }\n\n  if (options === null || options === void 0 ? void 0 : options.signer) {\n    return contract.connect(options.signer);\n  }\n\n  if (library === null || library === void 0 ? void 0 : library.getSigner()) {\n    return contract.connect(library.getSigner());\n  }\n\n  throw new TypeError('No signer available in contract, options or library');\n}\n/**\n * Hook returns an object with four variables: ``state`` , ``send``, ``events`` , and ``resetState``.\n *\n * The `state` represents the status of transaction. See {@link TransactionStatus}.\n *\n * `resetState` can be used to reset the state to `None` after a transaction attempt has either succeeded or failed.\n *\n * The `events` is a array of parsed transaction events of type [LogDescription](https://docs.ethers.io/v5/api/utils/abi/interface/#LogDescription).\n *\n * To send a transaction use `send` function returned by `useContractFunction`.\n * The function forwards arguments to ethers.js contract object, so that arguments map 1 to 1 with Solidity function arguments.\n * Additionally, there can be one extra argument - [TransactionOverrides](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend), which can be used to manipulate transaction parameters like gasPrice, nonce, etc\n *\n * If typechain contract is supplied as contract parameter then function name and send arguments will be type checked.\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n * @public\n * @param contract contract which function is to be called , also see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n * @param functionName name of function to call\n * @param options additional options of type {@link TransactionOptions}\n * @returns {} object with variables: `send` , `state` , `events`: `{ send: (...args: any[]) => void, state: TransactionStatus, events: LogDescription[] }`.\n *\n * @example\n * const { state, send } = useContractFunction(contract, 'deposit', { transactionName: 'Wrap' })\n *\n * const depositEther = (etherAmount: string) => {\n *   send({ value: utils.parseEther(etherAmount) })\n * }\n * @example\n * const { state, send } = useContractFunction(contract, 'withdraw', { transactionName: 'Unwrap' })\n *\n * const withdrawEther = (wethAmount: string) => {\n *   send(utils.parseEther(wethAmount))\n * }\n */\n\nexport function useContractFunction(contract, functionName, options) {\n  var _useEthers = useEthers(),\n      library = _useEthers.library,\n      chainId = _useEthers.chainId;\n\n  var _usePromiseTransactio = usePromiseTransaction(chainId, options),\n      promiseTransaction = _usePromiseTransactio.promiseTransaction,\n      state = _usePromiseTransactio.state,\n      resetState = _usePromiseTransactio.resetState;\n\n  var _useState = useState(undefined),\n      _useState2 = _slicedToArray(_useState, 2),\n      events = _useState2[0],\n      setEvents = _useState2[1];\n\n  var _useConfig = useConfig(),\n      _useConfig$bufferGasL = _useConfig.bufferGasLimitPercentage,\n      bufferGasLimitPercentage = _useConfig$bufferGasL === void 0 ? 0 : _useConfig$bufferGasL;\n\n  var send = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var _a,\n        _b,\n        _len,\n        args,\n        _key,\n        hasOpts,\n        contractWithSigner,\n        opts,\n        gasLimit,\n        modifiedOpts,\n        modifiedArgs,\n        receipt,\n        _events,\n        _args = arguments;\n\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!contract) {\n              _context.next = 15;\n              break;\n            }\n\n            for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = _args[_key];\n            }\n\n            hasOpts = args.length > ((_b = (_a = contract.interface) === null || _a === void 0 ? void 0 : _a.getFunction(functionName).inputs.length) !== null && _b !== void 0 ? _b : 0);\n            contractWithSigner = connectContractToSigner(contract, options, library);\n            opts = hasOpts ? args[args.length - 1] : undefined;\n            _context.next = 7;\n            return estimateGasLimit(opts, library === null || library === void 0 ? void 0 : library.getSigner(), bufferGasLimitPercentage);\n\n          case 7:\n            gasLimit = _context.sent;\n            modifiedOpts = Object.assign(Object.assign({}, opts), {\n              gasLimit: gasLimit\n            });\n            modifiedArgs = hasOpts ? args.slice(0, args.length - 1) : args;\n            modifiedArgs.push(modifiedOpts);\n            _context.next = 13;\n            return promiseTransaction(contractWithSigner[functionName].apply(contractWithSigner, _toConsumableArray(modifiedArgs)));\n\n          case 13:\n            receipt = _context.sent;\n\n            if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n              _events = receipt.logs.reduce(function (accumulatedLogs, log) {\n                try {\n                  return log.address.toLowerCase() === contract.address.toLowerCase() ? [].concat(_toConsumableArray(accumulatedLogs), [contract.interface.parseLog(log)]) : accumulatedLogs;\n                } catch (_err) {\n                  return accumulatedLogs;\n                }\n              }, []);\n              setEvents(_events);\n            }\n\n          case 15:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  })), [contract, functionName, options, library]);\n  return {\n    send: send,\n    state: state,\n    events: events,\n    resetState: resetState\n  };\n}","map":{"version":3,"mappings":"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","names":["useConfig","useCallback","useState","useEthers","estimateGasLimit","usePromiseTransaction","connectContractToSigner","contract","options","library","signer","connect","getSigner","TypeError","useContractFunction","functionName","chainId","promiseTransaction","state","resetState","undefined","events","setEvents","bufferGasLimitPercentage","send","args","hasOpts","length","interface","_a","getFunction","inputs","_b","contractWithSigner","opts","gasLimit","modifiedOpts","Object","modifiedArgs","slice","push","receipt","logs","reduce","accumulatedLogs","log","address","toLowerCase","parseLog","_err"],"sources":["/mnt/c/Users/dcmcc/Desktop/dan-mccarthy265.github.io/simple_web3_app/node_modules/@usedapp/core/src/hooks/useContractFunction.ts"],"sourcesContent":["import { TransactionOptions, useConfig } from '../../src'\nimport { Contract } from '@ethersproject/contracts'\nimport { JsonRpcProvider } from '@ethersproject/providers'\nimport { useCallback, useState } from 'react'\nimport { useEthers } from './useEthers'\nimport { estimateGasLimit, usePromiseTransaction } from './usePromiseTransaction'\nimport { LogDescription } from 'ethers/lib/utils'\nimport { ContractFunctionNames, Falsy, Params, TypedContract } from '../model/types'\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function connectContractToSigner(contract: Contract, options?: TransactionOptions, library?: JsonRpcProvider) {\n  if (contract.signer) {\n    return contract\n  }\n\n  if (options?.signer) {\n    return contract.connect(options.signer)\n  }\n\n  if (library?.getSigner()) {\n    return contract.connect(library.getSigner())\n  }\n\n  throw new TypeError('No signer available in contract, options or library')\n}\n\n/**\n * Hook returns an object with four variables: ``state`` , ``send``, ``events`` , and ``resetState``.\n *\n * The `state` represents the status of transaction. See {@link TransactionStatus}.\n *\n * `resetState` can be used to reset the state to `None` after a transaction attempt has either succeeded or failed.\n *\n * The `events` is a array of parsed transaction events of type [LogDescription](https://docs.ethers.io/v5/api/utils/abi/interface/#LogDescription).\n *\n * To send a transaction use `send` function returned by `useContractFunction`.\n * The function forwards arguments to ethers.js contract object, so that arguments map 1 to 1 with Solidity function arguments.\n * Additionally, there can be one extra argument - [TransactionOverrides](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend), which can be used to manipulate transaction parameters like gasPrice, nonce, etc\n *\n * If typechain contract is supplied as contract parameter then function name and send arguments will be type checked.\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n * @public\n * @param contract contract which function is to be called , also see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n * @param functionName name of function to call\n * @param options additional options of type {@link TransactionOptions}\n * @returns {} object with variables: `send` , `state` , `events`: `{ send: (...args: any[]) => void, state: TransactionStatus, events: LogDescription[] }`.\n *\n * @example\n * const { state, send } = useContractFunction(contract, 'deposit', { transactionName: 'Wrap' })\n *\n * const depositEther = (etherAmount: string) => {\n *   send({ value: utils.parseEther(etherAmount) })\n * }\n * @example\n * const { state, send } = useContractFunction(contract, 'withdraw', { transactionName: 'Unwrap' })\n *\n * const withdrawEther = (wethAmount: string) => {\n *   send(utils.parseEther(wethAmount))\n * }\n */\nexport function useContractFunction<T extends TypedContract, FN extends ContractFunctionNames<T>>(\n  contract: T | Falsy,\n  functionName: FN,\n  options?: TransactionOptions\n) {\n  const { library, chainId } = useEthers()\n  const { promiseTransaction, state, resetState } = usePromiseTransaction(chainId, options)\n  const [events, setEvents] = useState<LogDescription[] | undefined>(undefined)\n  const { bufferGasLimitPercentage = 0 } = useConfig()\n\n  const send = useCallback(\n    async (...args: Params<T, FN>): Promise<void> => {\n      if (contract) {\n        const hasOpts = args.length > (contract.interface?.getFunction(functionName).inputs.length ?? 0)\n\n        const contractWithSigner = connectContractToSigner(contract, options, library)\n        const opts = hasOpts ? args[args.length - 1] : undefined\n        const gasLimit = await estimateGasLimit(opts, library?.getSigner(), bufferGasLimitPercentage)\n\n        const modifiedOpts = {\n          ...opts,\n          gasLimit,\n        }\n        const modifiedArgs = hasOpts ? args.slice(0, args.length - 1) : args\n        modifiedArgs.push(modifiedOpts)\n\n        const receipt = await promiseTransaction(contractWithSigner[functionName](...modifiedArgs))\n        if (receipt?.logs) {\n          const events = receipt.logs.reduce((accumulatedLogs, log) => {\n            try {\n              return log.address.toLowerCase() === contract.address.toLowerCase()\n                ? [...accumulatedLogs, contract.interface.parseLog(log)]\n                : accumulatedLogs\n            } catch (_err) {\n              return accumulatedLogs\n            }\n          }, [] as LogDescription[])\n          setEvents(events)\n        }\n      }\n    },\n    [contract, functionName, options, library]\n  )\n\n  return { send, state, events, resetState }\n}\n"]},"metadata":{},"sourceType":"module"}